


  {
  
  
    "properties" : {},
  
  "type" : "lab",
  "title" : "Lab-7 Glitch Playlist 3",
  "img" : "img/main.jpg",
  "videoid" : "none",
  "objectives" : "<p>Enable Songs and Playlists to be added via simple forms.</p>",
  "folder" : "book-a-glitch-playlist-3",
  "link" : "index.html",
  "los": [
   ]
,
  "chapters" : [
  
    {
    "title": "#Objectives",
    "shortTitle": "Lab-7 Glitch Playlist 3",
    "contentMd" : "#Objectives\r\n\r\nEnable Songs and Playlists to be added via simple forms.\r\n\r\n"
    },
  
    {
    "title": "# Exercise Solutions",
    "shortTitle": "Exercise Solutions",
    "contentMd" : "# Exercise Solutions\r\n\r\nThis lab requires that the `Glitch-playlist-2` lab be completed. If you have lost your solution, create a new project in Glitch and select the `import from github` option and enter `rbirney/playlist2-complete` to import a completed version.\r\n\r\n**Note:** All the tasks below are completed in the downloaded version, so take your time to look through the solutions.\r\n\r\n## Exercise 1: UX Enhancements & Exercise 3: listplaylists partial\r\n\r\nIntroduce a 'Delete Playlist' button for each playlist, represented by a `trash` icon.\r\n\r\n## views/dashboard.hbs\r\n\r\n~~~html\r\n{{> menu id=\"dashboard\"}}\r\n\r\n<section class=\"ui segment\">\r\n  {{> listplaylists}}\r\n</section>\r\n~~~\r\n\r\n## views/partials/listplaylists.hbs\r\n\r\n~~~html\r\n{{#each playlists}}\r\n  <section class=\"ui stacked segment\">\r\n    <h2 class=\"ui header\">\r\n      {{title}}\r\n    </h2>\r\n    <p> Total Duration: {{duration}} </p>\r\n    <a href=\"/playlist/{{id}}\" class=\"ui icon button\">\r\n      <i class=\"icon folder open\"></i>\r\n    </a>\r\n    <a href=\"/dashboard/deleteplaylist/{{id}}\" class=\"ui icon button\">\r\n      <i class=\"icon trash\"></i>\r\n    </a>\r\n  </section>\r\n{{/each}}\r\n~~~\r\n\r\n## Exercise 2: Delete Playlist Functionality\r\n\r\nMake the button actually delete the denoted playlist.\r\n\r\n## routes.js\r\n\r\n~~~js\r\n...\r\nrouter.get('/dashboard/deleteplaylist/:id', dashboard.deletePlaylist);\r\n...\r\n~~~\r\n\r\n## controllers/dashboard.js\r\n\r\n~~~js\r\n...\r\n  deletePlaylist(request, response) {\r\n    const playlistId = request.params.id;\r\n    logger.debug(`Deleting Playlist ${playlistId}`);\r\n    playlistStore.removePlaylist(playlistId);\r\n    response.redirect('/dashboard');\r\n  },\r\n...\r\n~~~\r\n\r\n## models/playlist-store.js\r\n\r\n~~~js\r\n  removePlaylist(id) {\r\n    _.remove(this.playlistCollection, { id: id });\r\n  },\r\n~~~\r\n"
    },
  
    {
    "title": "# Adding a Song",
    "shortTitle": "01",
    "contentMd" : "# Adding a Song\r\n\r\nBefore adding a song (`listsongs.hbs`), lets align the delete button appearance with the delete playlist. Use this icon button instead of the existing one:\r\n\r\n~~~html\r\n<a href=\"/playlist/{{../playlist.id}}/deletesong/{{id}}\" class=\"ui icon button\">\r\n  <i class=\"icon trash\"></i>\r\n</a>\r\n~~~\r\n\r\nIn order to add songs, we need this new partial which provides a simple add song form:\r\n\r\n## views/partials/addsong.hbs\r\n\r\n~~~html\r\n<form class=\"ui stacked segment form\" action=\"/playlist/{{playlist.id}}/addsong\" method=\"POST\">\r\n  <div class=\"two fields\">\r\n    <div class=\"field\">\r\n      <label>Title</label>\r\n      <input placeholder=\"Title\" type=\"text\" name=\"title\" autofocus required>\r\n    </div>\r\n    <div class=\"field\">\r\n      <label>Artist</label>\r\n      <input placeholder=\"Artist\" type=\"text\" name=\"artist\" required>\r\n    </div>\r\n  </div>\r\n  <button class=\"ui blue submit button\">Add Song</button>\r\n</form>\r\n~~~\r\n\r\nThen we need to include this in the playlist view:\r\n\r\n## views/playlist.hbs\r\n\r\n~~~\r\n{{> menu}}\r\n\r\n<section class=\"ui center aligned middle aligned segment\">\r\n  <h2 class=\"ui header\">\r\n    {{playlist.title}}\r\n  </h2>\r\n  {{> listsongs}}\r\n  {{> addsong}}\r\n</section>~~~\r\n\r\nThis should now appear:\r\n\r\n![](img/01.png)\r\n\r\nThis requires a new route to support the `POST` action:\r\n\r\n## routes.js\r\n\r\n~~~js\r\nrouter.post('/playlist/:id/addsong', playlist.addSong);\r\n~~~\r\n\r\n... and this new function in the `playlist` controller:\r\n\r\n## controllers/playlist.js\r\n\r\n~~~js\r\n...\r\n  addSong(request, response) {\r\n    const playlistId = request.params.id;\r\n    const playlist = playlistStore.getPlaylist(playlistId);\r\n    const newSong = {\r\n      title: request.body.title,\r\n      artist: request.body.artist,\r\n    };\r\n    playlistStore.addSong(playlistId, newSong);\r\n    response.redirect('/playlist/' + playlistId);\r\n  },\r\n...\r\n~~~\r\n\r\nThis is the implementation of the `addSong` method in the store:\r\n\r\n## models/playlist-store.js\r\n\r\n~~~js\r\n  addSong(id, song) {\r\n    const playlist = this.getPlaylist(id);\r\n    playlist.songs.push(song);\r\n  },\r\n~~~\r\n\r\nTry this now and verify that you can add songs.\r\n\r\nCan you delete one of the songs you have just added? Can you delete one of the songs that have been in there already? Can you explain what is going wrong?\r\n"
    },
  
    {
    "title": "# ID Management",
    "shortTitle": "02",
    "contentMd" : "# ID Management\r\n\r\nDeleting a song you have manually added using the form generates the following:\r\n\r\n~~~\r\nCannot GET /playlist/02/deletesong/\r\n~~~\r\n\r\nHowever, pre-populated songs can still be deleted. What is going on here?\r\n\r\nThe issue is that the new songs we have added do not appear to have IDs. Looking at this list for instance:\r\n\r\n![](img/02.png)\r\n\r\nRevealing the source:\r\n\r\n![](img/03.png)\r\n\r\nLook at the last entry - there is no ID for the new song we added.\r\n\r\nHere is our `addsong` function again:\r\n\r\n## controllers/playlist.js\r\n\r\n~~~js\r\n  addSong(request, response) {\r\n    const playlistId = request.params.id;\r\n    const playlist = playlistStore.getPlaylist(playlistId);\r\n    const newSong = {\r\n      title: request.body.title,\r\n      artist: request.body.artist,\r\n    };\r\n    playlistStore.addSong(playlistId, newSong);\r\n    response.redirect('/playlist/' + playlistId);\r\n  },\r\n~~~\r\n\r\nThe object we are inserting has only two fields:\r\n\r\n~~~js\r\n    const newSong = {\r\n      title: request.body.title,\r\n      artist: request.body.artist,\r\n    };\r\n~~~\r\n\r\nWe need to also insert a new, unique, ID for each object we create.\r\n\r\nHow do we create a new ID? This can be challenged in implement manually. However, one solution is to use Universally Unique Identifiers:\r\n\r\n- <a href=\"https://en.wikipedia.org/wiki/Universally_unique_identifier>\" target=\"_blank\">`https://en.wikipedia.org/wiki/Universally_unique_identifier`</a>\r\n\r\nA library to generate a uuid is already in our app, we just need to import and use it.\r\n\r\nAt the top of the `playlist` controller, we require the library:\r\n\r\n## controllers/playlist.js\r\n~~~\r\nconst uuid = require('uuid');\r\n~~~\r\n\r\nNow, when we are creating a playlist, we can use the library to generate a unique id for us:\r\n\r\n~~~js\r\n  const newSong = {\r\n    id: uuid(),\r\n    title: request.body.title,\r\n    artist: request.body.artist,\r\n  };\r\n~~~\r\n\r\nTry this now and make sure the new songs can be deleted. View the source to reveal the uuid-style ids the new songs have.\r\n"
    },
  
    {
    "title": "# Adding playlists",
    "shortTitle": "03",
    "contentMd" : "# Adding playlists\r\n\r\nModeled on the Song addition, we can quickly implement the necessary form, route, controller function and model update to support adding a new playlist.\r\n\r\n## views/partials/addplaylist.hbs\r\n\r\n~~~html\r\n<form class=\"ui stacked segment form\" action=\"/dashboard/addplaylist\" method=\"POST\">\r\n  <div class=\"field\">\r\n    <label>Title</label>\r\n    <input placeholder=\"Title\" type=\"text\" name=\"title\" autofocus required>\r\n  </div>\r\n  <button class=\"ui blue submit button\">Add Playlist</button>\r\n</form>\r\n~~~\r\n\r\n## views/dashboard.hbs\r\n\r\n~~~html\r\n{{> menu id=\"dashboard\"}}\r\n\r\n<section class=\"ui segment\">\r\n  {{> listplaylists}}\r\n  {{> addplaylist}}\r\n</section>\r\n~~~\r\n\r\n## routes.js\r\n\r\n~~~js\r\nrouter.post('/dashboard/addplaylist', dashboard.addPlaylist);\r\n~~~\r\n\r\n## controllers/dashboard.js\r\n\r\n~~~js\r\nconst uuid = require('uuid');\r\n...\r\n  addPlaylist(request, response) {\r\n    const newPlayList = {\r\n      id: uuid(),\r\n      title: request.body.title,\r\n      songs: [],\r\n    };\r\n    playlistStore.addPlaylist(newPlayList);\r\n    response.redirect('/dashboard');\r\n  },\r\n~~~\r\n\r\nNotice we are again using the uuid library here to generate and ID for the new playlist\r\n\r\n## models/playlist-store.js\r\n\r\n~~~js\r\naddPlaylist(playlist) {\r\n  this.playlistCollection.push(playlist);\r\n},\r\n~~~\r\n\r\nWe should now be able to add new playlists.\r\n"
    },
  
    {
    "title": "# Persistence",
    "shortTitle": "04",
    "contentMd" : "# Persistence\r\n\r\nYou will note that, even though we are able to add/delete playlists/songs, every time the app restarts then we are left with the same initial playlist. i.e. none of the changes we make are `persisted` beyond the life of the program execution.\r\n\r\nThis is the field of databases - and beyond the scope of this module for the moment. However, we can implement something like a database, but simpler, which can serve our needs. Introduce this new class into the project:\r\n\r\n## models/json-store.js\r\n\r\n~~~js\r\n'use strict';\r\n\r\nconst low = require('lowdb');\r\nconst fileAsync = require('lowdb/lib/file-async');\r\n\r\nclass JsonStore {\r\n  constructor(file, defaults) {\r\n    this.db = low(file, { storage: fileAsync, });\r\n    this.db.defaults(defaults).value();\r\n  }\r\n\r\n  add(collection, obj) {\r\n    this.db.get(collection).push(obj).last().value();\r\n  }\r\n\r\n  remove(collection, obj) {\r\n    this.db.get(collection).remove(obj).value();\r\n  }\r\n\r\n  removeAll(collection) {\r\n    this.db.get(collection).remove().value();\r\n  }\r\n\r\n  findAll(collection) {\r\n    return this.db.get(collection).value();\r\n  }\r\n\r\n  findOneBy(collection, filter) {\r\n    const results = this.db.get(collection).filter(filter).value();\r\n    return results[0];\r\n  }\r\n\r\n  findByIds(collection, ids) {\r\n    return this.db.get(collection).keyBy('id').at(ids).value();\r\n  }\r\n\r\n  findBy(collection, filter) {\r\n    return this.db.get(collection).filter(filter).value();\r\n  }\r\n}\r\n\r\nmodule.exports = JsonStore;\r\n~~~\r\n\r\nThis is a wrapper around this module:\r\n\r\n- <a href=\"https://github.com/typicode/lowdb\" target=\"_blank\">`https://github.com/typicode/lowdb`</a>\r\n\r\nIt will manage the json file we have been using, enabling updates in a convenient manner. You do not need to understand this module in depth for the moment, we will use another wrapper module to interact with it.\r\n\r\nHere is the wrapper, which is a new version of our playlist store module:\r\n\r\n## models/playlist-store.js\r\n\r\n~~~js\r\n'use strict';\r\n\r\nconst _ = require('lodash');\r\nconst JsonStore = require('./json-store');\r\n\r\nconst playlistStore = {\r\n\r\n  store: new JsonStore('./models/playlist-store.json', { playlistCollection: [] }),\r\n  collection: 'playlistCollection',\r\n\r\n  getAllPlaylists() {\r\n    return this.store.findAll(this.collection);\r\n  },\r\n\r\n  getPlaylist(id) {\r\n    return this.store.findOneBy(this.collection, { id: id });\r\n  },\r\n\r\n  addPlaylist(playlist) {\r\n    this.store.add(this.collection, playlist);\r\n  },\r\n\r\n  removePlaylist(id) {\r\n    const playlist = this.getPlaylist(id);\r\n    this.store.remove(this.collection, playlist);\r\n  },\r\n\r\n  removeAllPlaylists() {\r\n    this.store.removeAll(this.collection);\r\n  },\r\n\r\n  addSong(id, song) {\r\n    const playlist = this.getPlaylist(id);\r\n    playlist.songs.push(song);\r\n  },\r\n\r\n  removeSong(id, songId) {\r\n    const playlist = this.getPlaylist(id);\r\n    const songs = playlist.songs;\r\n    _.remove(songs, { id: songId});\r\n  },\r\n};\r\n\r\nmodule.exports = playlistStore;\r\n~~~\r\n\r\nNo other changes are necessary - as all access to the playlist is via the above module.\r\n\r\nThe app should work now as before, except this time changes to the playlists will be `persisted` to the json file. This means that if the app has to be restarted, it will have preserved any changes to the playlist in the JSON file, which will be reloaded when the app restarts.\r\n\r\nTry this now - and keep an eye on the `playlist-store.json` file. Because of the way Glitch works, you may only see the updated json when you refresh the page. Glitch can also be restarted in the console:\r\n\r\n- Go to the 'Tools' menu and click on console:\r\n\r\n![](img/04.png)\r\n\r\n- In the console, type 'refresh':\r\n\r\n![](img/05.png)\r\n\r\n"
    },
  
    {
    "title": "# Exercises",
    "shortTitle": "Exercises",
    "contentMd" : "# Exercises\r\n\r\nIf you want to download a complete version of the app as it should be at the end of this lab, then create a new Glitch project, and import `rbirney/playlist3-complete`.\r\n"
    }
  
  ]
  }

